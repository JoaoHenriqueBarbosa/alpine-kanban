<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanban Board</title>
  <script>
    // Check for download query param
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('download') === 'true') {
      fetch('https://raw.githubusercontent.com/JoaoHenriqueBarbosa/alpine-kanban/refs/heads/main/index.html')
        .then(response => response.text())
        .then(data => {
          const blob = new Blob([data], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'index.html';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          // Remove the download param from URL
          urlParams.delete('download');
          const newUrl = window.location.pathname + (urlParams.toString() ? '?' + urlParams.toString() : '');
          window.history.replaceState({}, '', newUrl);
        });
    }
  </script>
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script>
    // Setup Alpine Store
    document.addEventListener('alpine:init', () => {
      Alpine.store('kanban', {
        cards: [],
        columns: [
          { id: 'todo', title: 'A Fazer' },
          { id: 'doing', title: 'Fazendo' },
          { id: 'done', title: 'Feito' }
        ],

        init() {
          this.loadState();
        },

        loadState() {
          try {
            const savedData = localStorage.getItem('kanbanState');
            if (savedData) {
              const data = JSON.parse(savedData);
              this.cards = data.cards;
              this.columns = data.columns;
            }
          } catch (e) {
            console.error('Erro ao carregar dados do localStorage:', e);
          }
        },

        saveState() {
          try {
            localStorage.setItem('kanbanState', JSON.stringify({
              cards: this.cards,
              columns: this.columns
            }));
          } catch (e) {
            console.error('Erro ao salvar estado:', e);
          }
        },

        generateId() {
          return Math.random().toString(36).substr(2, 9);
        },

        getCardsByColumn(columnId) {
          return this.cards.filter(card => card.status === columnId);
        }
      });
    });
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      margin: 0;
      padding: 20px;
      color: #e0e0e0;
    }

    h1 {
      text-align: center;
      color: #ffffff;
    }

    .kanban {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .column {
      background-color: #2d2d2d;
      border-radius: 8px;
      padding: 16px;
      width: 100%;
      max-width: 350px;
      min-height: 400px;
    }

    .column h2 {
      text-align: left;
      color: #ffffff;
      margin-top: 0;
      font-size: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid #3d3d3d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .column h2 button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 20px;
      padding: 0 4px;
    }

    .card {
      background-color: #3d3d3d;
      border-radius: 4px;
      margin: 10px 0;
      color: #e0e0e0;
      border: 1px solid #4d4d4d;
      position: relative;
    }

    .card .card-header {
      height: 32px;
      background-color: #4d4d4d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 8px;
    }

    .card .card-header .drag-handle {
      display: flex;
      align-items: center;
      opacity: 0.5;
      cursor: grab;
    }

    .card .card-header .drag-handle:hover {
      opacity: 1;
    }

    .card .card-header .drag-handle svg {
      width: 10px;
      height: 16px;
    }

    .card .card-header .title-area {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      margin: 0 8px;
    }

    .card .card-header span {
      font-size: 14px;
      color: #ffffff;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
      min-width: 60px;
    }

    .card .card-header span:hover {
      background-color: #5d5d5d;
    }

    .card .card-header span:focus {
      background-color: #5d5d5d;
      outline: none;
    }

    .card .card-header .buttons {
      display: flex;
      gap: 8px;
    }

    .card .card-header button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      opacity: 0.7;
    }

    .card .card-header button:hover {
      opacity: 1;
    }

    .card .card-header button.delete {
      color: #ff4444;
    }

    .card h3 {
      margin: 0;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card h3 .buttons {
      display: flex;
      gap: 8px;
    }

    .card h3 button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      opacity: 0.7;
    }

    .card h3 button:hover {
      opacity: 1;
    }

    .card h3 button.delete {
      color: #ff4444;
    }

    .card:active {
      cursor: grabbing;
    }

    .card.dragging {
      opacity: 0.5;
      outline: 2px solid #ffffff;
    }

    .card ul {
      list-style-type: none;
      padding: 0;
      margin: 10px 0 0 0;
    }

    .card ul li {
      margin: 8px 0;
      display: flex;
      align-items: start;
      color: #cccccc;
      font-size: 14px;
      padding-bottom: 6px;
      position: relative;
    }

    .card ul li:not(:last-child) {
      border-bottom: 1px solid #4d4d4d;
    }

    .card ul li button.delete-task {
      background: none;
      border: none;
      color: #ff4444;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
      opacity: 0;
      margin-left: 4px;
    }

    .card ul li:hover button.delete-task {
      opacity: 0.7;
    }

    .card ul li button.delete-task:hover {
      opacity: 1;
    }

    .card .card-content {
      padding: 0 12px 0 12px;
    }

    .toolbar {
      text-align: right;
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .toolbar button {
      background-color: #2d2d2d;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .toolbar button:active {
      background-color: #4d4d4d;
    }

    .toolbar button svg {
      width: 16px;
      height: 16px;
    }

    .toolbar button path {
      fill: currentColor;
    }

    .toolbar button[onclick="reset()"],
    .toolbar button[onclick="reset()"]:hover,
    .toolbar button[onclick="downloadState()"],
    .toolbar button[onclick="downloadState()"]:hover,
    .toolbar button[onclick="document.getElementById('uploadInput').click()"],
    .toolbar button[onclick="document.getElementById('uploadInput').click()"]:hover {
      background-color: #2d2d2d;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background-color: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
    }

    .modal-content h3 {
      margin-top: 0;
      color: #ffffff;
    }

    .modal-content input[type="text"] {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      background-color: #3d3d3d;
      border: 1px solid #4d4d4d;
      color: #ffffff;
      border-radius: 4px;
    }

    .modal-content .buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-content button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .modal-content button.cancel {
      background-color: #272727;
      color: #ffffff;
    }

    .modal-content button.confirm {
      background-color: #1e2f50;
      color: #ffffff;
    }

    .card h3 span {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
    }

    .card h3 span:hover {
      background-color: #4d4d4d;
    }

    .card h3 span:focus {
      background-color: #4d4d4d;
      outline: none;
    }

    .card ul li span {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
    }

    .card ul li span:hover {
      background-color: #4d4d4d;
    }

    .card ul li span:focus {
      background-color: #4d4d4d;
      outline: none;
    }

    .toolbar {
      text-align: right;
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .toolbar button {
      background-color: #2d2d2d;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .toolbar button:active {
      background-color: #4d4d4d;
    }

    .toolbar button svg {
      width: 16px;
      height: 16px;
    }

    .toolbar button path {
      fill: currentColor;
    }

    .toolbar button[onclick="reset()"],
    .toolbar button[onclick="reset()"]:hover,
    .toolbar button[onclick="downloadState()"],
    .toolbar button[onclick="downloadState()"]:hover,
    .toolbar button[onclick="document.getElementById('uploadInput').click()"],
    .toolbar button[onclick="document.getElementById('uploadInput').click()"]:hover {
      background-color: #4d4d4d;
    }

    .toolbar button:hover {
      background-color: #4d4d4d;
    }

    .outline {
      outline: 2px solid #ffffff;
    }

    /* Estilo do checkbox customizado */
    .card ul li input[type="checkbox"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border: 2px solid #dddddd;
      border-radius: 4px;
      margin-right: 8px;
      flex-shrink: 0;
      cursor: pointer;
      position: relative;
      background-color: transparent;
      transition: all 0.2s ease;
    }

    .card ul li input[type="checkbox"]:hover {
      border-color: #8b8b8b;
    }

    .card ul li input[type="checkbox"]:checked {
      background-color: #dddddd;
      border-color: #dddddd;
    }

    .card ul li input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 5px;
      top: 2px;
      width: 4px;
      height: 8px;
      border: solid rgb(0, 0, 0);
      border-width: 0 2px 2px 0;
      transform: rotate(45deg) translate(-2px, -0.5px);
    }

    .card ul li input[type="checkbox"]:checked+span {
      text-decoration: line-through;
      opacity: 0.6;
    }

    [x-cloak] {
      display: none !important;
    }
  </style>
</head>

<body>
  <h1>Kanban Board</h1>
  <div x-data="{
    ...kanbanBoard(),
    isShortcutsModalOpen: false
  }">
    <div class="toolbar">
      <button role="button" @click="reset">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" />
        </svg>
        Resetar
      </button>
      <button role="button" @click="downloadState">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
        </svg>
        Baixar
      </button>
      <button role="button" @click="$refs.uploadInput.click()">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z" />
        </svg>
        Carregar
      </button>
      <button role="button" @click="isShortcutsModalOpen = true">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2z" />
        </svg>
        Atalhos
      </button>
      <input type="file" x-ref="uploadInput" accept=".json" style="display: none;" @change="uploadState($event)">
    </div>
    <div class="kanban">
      <template x-for="column in $store.kanban.columns" :key="column.id">
        <div class="column" :id="column.id" @dragover.prevent="handleDragOver($event, column.id)">
          <h2>
            <span x-text="column.title"></span>
            <button @click="createCard(column.id)">+</button>
          </h2>

          <template x-for="card in $store.kanban.getCardsByColumn(column.id)" :key="card.id">
            <div :class="{ 'card': true, 'outline': cargMovingWithShift === card.id }" :data-card-id="card.id"
              draggable="true" @dragstart="handleDragStart($event, card)"
              @dragend="handleDragEnd($event, column.id, card)">
              <div class="card-header">
                <div class="drag-handle">
                  <svg viewBox="0 0 12 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="3" cy="3" r="1.5" fill="#ffffff" />
                    <circle cx="9" cy="3" r="1.5" fill="#ffffff" />
                    <circle cx="3" cy="9" r="1.5" fill="#ffffff" />
                    <circle cx="9" cy="9" r="1.5" fill="#ffffff" />
                    <circle cx="3" cy="15" r="1.5" fill="#ffffff" />
                    <circle cx="9" cy="15" r="1.5" fill="#ffffff" />
                  </svg>
                </div>
                <div class="title-area">
                  <span contenteditable="true" @blur="updateCardTitle(card.id, $event.target.textContent.trim())"
                    @keydown.enter.prevent="$event.ctrlKey ? handleTaskCtrlEnter($event, card) : handleTitleEnter($event, card)"
                    @keydown.shift.prevent="cargMovingWithShift = card.id" @keyup.shift="cargMovingWithShift = null"
                    @keydown.shift.arrow-up.prevent="moveCard(card.id, 'up', $event)"
                    @keydown.shift.arrow-down.prevent="moveCard(card.id, 'down', $event)"
                    @keydown.shift.arrow-left.prevent="moveCard(card.id, 'left', $event)"
                    @keydown.shift.arrow-right.prevent="moveCard(card.id, 'right', $event)"
                    @keydown.alt.arrow-up.prevent="navigateCardTitles($event.target, 'up')"
                    @keydown.alt.arrow-down.prevent="navigateCardTitles($event.target, 'down')"
                    @keydown.alt.arrow-left.prevent="navigateColumns($event.target, 'left', $event)"
                    @keydown.alt.arrow-right.prevent="navigateColumns($event.target, 'right', $event)"
                    @keydown.arrow-up.prevent="navigateEditables($event.target, 'up', $event.altKey)"
                    @keydown.arrow-down.prevent="navigateEditables($event.target, 'down', $event.altKey)"
                    @keydown.delete.prevent="deleteCard(card.id)" x-text="card.title"></span>
                </div>
                <div class="buttons">
                  <button @click="createTaskAndFocus(card.id)" title="Adicionar tarefa">+</button>
                  <button class="delete" @click="deleteCard(card.id)" title="Excluir card">×</button>
                </div>
              </div>
              <div class="card-content">
                <ul>
                  <template x-for="(item, index) in card.items" :key="index">
                    <li>
                      <input type="checkbox" :checked="item.checked"
                        @change="updateTaskCheck(card.id, index, $event.target.checked)">
                      <span contenteditable="true"
                        @blur="updateTaskText(card.id, index, $event.target.textContent.trim())"
                        @keydown.enter.prevent="$event.ctrlKey ? handleTaskCtrlEnter($event, card) : createTaskAndFocus(card.id, index)"
                        @keydown.shift.prevent="cargMovingWithShift = card.id" @keyup.shift="cargMovingWithShift = null"
                        @keydown.shift.arrow-up.prevent="moveCard(card.id, 'up', $event)"
                        @keydown.shift.arrow-down.prevent="moveCard(card.id, 'down', $event)"
                        @keydown.shift.arrow-left.prevent="moveCard(card.id, 'left', $event)"
                        @keydown.shift.arrow-right.prevent="moveCard(card.id, 'right', $event)"
                        @keydown.ctrl.arrow-up.prevent="moveTask(card.id, index, 'up')"
                        @keydown.ctrl.arrow-down.prevent="moveTask(card.id, index, 'down')"
                        @keydown.alt.arrow-up.prevent="navigateCardTitles($event.target, 'up')"
                        @keydown.alt.arrow-down.prevent="navigateCardTitles($event.target, 'down')"
                        @keydown.alt.arrow-left.prevent="navigateColumns($event.target, 'left', $event)"
                        @keydown.alt.arrow-right.prevent="navigateColumns($event.target, 'right', $event)"
                        @keydown.arrow-up.prevent="navigateEditables($event.target, 'up', $event.altKey)"
                        @keydown.arrow-down.prevent="navigateEditables($event.target, 'down', $event.altKey)"
                        @keydown.delete.prevent="deleteTask(card.id, index)" x-text="item.text"></span>
                      <button class="delete-task" @click="deleteTask(card.id, index)" title="Excluir tarefa">×</button>
                    </li>
                  </template>
                </ul>
              </div>
            </div>
          </template>
        </div>
      </template>
    </div>

    <!-- Modal de Atalhos -->
    <div class="modal-overlay" x-cloak x-show="isShortcutsModalOpen" x-transition:enter="fade-enter"
      x-transition:enter-start="fade-enter-start" x-transition:enter-end="fade-enter-end"
      x-transition:leave="fade-leave" x-transition:leave-start="fade-leave-start"
      x-transition:leave-end="fade-leave-end" @click="isShortcutsModalOpen = false">
      <div class="modal-content" @click.stop>
        <h2>Atalhos de Teclado</h2>

        <h3>Navegação</h3>
        <ul>
          <li><kbd>↑</kbd> / <kbd>↓</kbd> - Navega entre elementos editáveis na mesma coluna</li>
          <li><kbd>Alt</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd> - Navega apenas entre títulos dos cards na mesma coluna</li>
          <li><kbd>Alt</kbd> + <kbd>←</kbd> / <kbd>→</kbd> - Navega para o card na mesma posição na coluna adjacente
          </li>
        </ul>

        <h3>Movimentação de Cards</h3>
        <ul>
          <li><kbd>Shift</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd> - Move o card para cima/baixo na mesma coluna</li>
          <li><kbd>Shift</kbd> + <kbd>←</kbd> / <kbd>→</kbd> - Move o card para a coluna da esquerda/direita mantendo a
            mesma posição</li>
        </ul>

        <h3>Movimentação de Tarefas</h3>
        <ul>
          <li><kbd>Ctrl</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd> - Move a tarefa para cima/baixo dentro do card</li>
        </ul>

        <h3>Edição</h3>
        <ul>
          <li><kbd>Enter</kbd> no título - Cria uma nova tarefa no topo do card</li>
          <li><kbd>Ctrl</kbd> + <kbd>Enter</kbd> no título - Cria novo card abaixo do atual</li>
          <li><kbd>Enter</kbd> em uma tarefa - Cria nova tarefa abaixo</li>
          <li><kbd>Ctrl</kbd> + <kbd>Enter</kbd> em uma tarefa - Cria novo card abaixo do atual</li>
          <li><kbd>Delete</kbd> no título - Exclui o card (com confirmação)</li>
          <li><kbd>Delete</kbd> em uma tarefa - Exclui a tarefa imediatamente</li>
        </ul>

        <div class="modal-buttons">
          <button @click="isShortcutsModalOpen = false">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
            </svg>
            Fechar
          </button>
        </div>
      </div>
    </div>
  </div>

  <style>
    /* Estilo do modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #2d2d2d;
      padding: 24px;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-content h2 {
      margin: 0 0 20px 0;
      font-size: 24px;
      color: #ffffff;
    }

    .modal-content h3 {
      margin: 24px 0 12px 0;
      font-size: 18px;
      color: #dddddd;
    }

    .modal-content h3:first-of-type {
      margin-top: 0;
    }

    .modal-content ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .modal-content li {
      margin: 8px 0;
      font-size: 14px;
      color: #cccccc;
    }

    .modal-content kbd {
      background: #1a1a1a;
      border: 1px solid #4d4d4d;
      border-radius: 4px;
      padding: 2px 6px;
      font-family: monospace;
      font-size: 12px;
      color: #ffffff;
    }

    .modal-buttons {
      margin-top: 24px;
      display: flex;
      justify-content: flex-end;
    }

    .modal-buttons button {
      background-color: #222222;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal-buttons button:hover {
      background-color: #252525;
    }

    .modal-buttons button:active {
      background-color: #313131;
    }

    .modal-buttons button svg {
      width: 16px;
      height: 16px;
    }

    .modal-buttons button path {
      fill: currentColor;
    }

    /* Animações do modal */
    .fade-enter {
      transition: opacity 0.2s ease-out;
    }

    .fade-enter-start {
      opacity: 0;
    }

    .fade-enter-end {
      opacity: 1;
    }

    .fade-leave {
      transition: opacity 0.2s ease-in;
    }

    .fade-leave-start {
      opacity: 1;
    }

    .fade-leave-end {
      opacity: 0;
    }
  </style>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('kanbanBoard', () => ({
        draggedCard: null,
        draggedCardData: null,
        sourceColumnId: null,
        originalPosition: null,
        columnOverId: null,
        cargMovingWithShift: null,
        isShortcutsModalOpen: false,

        init() {
          // Clickaway listener para salvar edições ao clicar fora
          document.addEventListener('click', (e) => {
            const activeElement = document.activeElement;
            const clickedElement = e.target;

            if (activeElement &&
              activeElement.getAttribute('contenteditable') === 'true' &&
              !activeElement.contains(clickedElement) &&
              activeElement !== clickedElement) {
              activeElement.blur();
            }
          });

          // Listener para fechar o modal com Esc
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isShortcutsModalOpen) {
              this.isShortcutsModalOpen = false;
            }
          });
        },

        createCard(columnId) {
          const newCard = {
            id: this.$store.kanban.generateId(),
            status: columnId,
            title: '',
            items: []
          };

          this.$store.kanban.cards.push(newCard);
          this.$store.kanban.saveState();

          this.$nextTick(() => {
            const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
            if (cardElement) {
              const titleElement = cardElement.querySelector('.title-area span');
              if (titleElement) {
                titleElement.focus();
              }
            }
          });
        },

        createTaskAndFocus(cardId, afterIndex = -1, atTop = false) {
          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (card) {
            const newTask = {
              text: '',
              checked: false
            };

            if (atTop) {
              card.items.unshift(newTask);
            } else if (afterIndex >= 0) {
              card.items.splice(afterIndex + 1, 0, newTask);
            } else {
              card.items.push(newTask);
            }

            this.$store.kanban.saveState();

            this.$nextTick(() => {
              const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
              if (cardElement) {
                const tasks = cardElement.querySelectorAll('.card-content span[contenteditable]');
                const newTaskElement = atTop ? tasks[0] : tasks[afterIndex + 1];
                if (newTaskElement) {
                  newTaskElement.focus();
                }
              }
            });
          }
        },

        updateCardTitle(cardId, newTitle) {
          if (!newTitle) return;

          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (card) {
            card.title = newTitle;
            this.$store.kanban.saveState();
          }
        },

        updateTaskText(cardId, taskIndex, newText) {
          if (!newText) return;

          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (card && card.items[taskIndex]) {
            card.items[taskIndex].text = newText;
            this.$store.kanban.saveState();
          }
        },

        updateTaskCheck(cardId, taskIndex, checked) {
          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (card && card.items[taskIndex]) {
            card.items[taskIndex].checked = checked;
            this.$store.kanban.saveState();
          }
        },

        deleteCard(cardId) {
          if (confirm('Tem certeza que deseja excluir este card?')) {
            this.$store.kanban.cards = this.$store.kanban.cards.filter(card => card.id !== cardId);
            this.$store.kanban.saveState();
          }
        },

        deleteTask(cardId, taskIndex) {
          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (card) {
            card.items.splice(taskIndex, 1);
            this.$store.kanban.saveState();

            // Focar na próxima tarefa ou na anterior se não houver próxima
            this.$nextTick(() => {
              const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
              if (cardElement) {
                const tasks = cardElement.querySelectorAll('.card-content span[contenteditable]');
                if (tasks.length > 0) {
                  const nextTask = tasks[taskIndex] || tasks[taskIndex - 1];
                  if (nextTask) {
                    nextTask.focus();
                  }
                }
              }
            });
          }
        },

        handleDragStart(event, card) {
          if (Object.keys(event.target).length > 0) {
            this.draggedCard = event.target;
            this.draggedCardData = card;
            this.sourceColumnId = card.status;
            setTimeout(() => event.target.classList.add('dragging'), 0);
          }
        },

        handleDragEnd(event, columnId, card) {
          if (!this.draggedCardData) return;

          const column = event.target.closest('.column');
          if (!column) return;

          // get card new position on column
          const newColumn = document.querySelector(`#${this.columnOverId}`);
          const newColumnCards = newColumn.querySelectorAll('.card');
          const newCardIndex = Array.from(newColumnCards).indexOf(event.target);

          if (columnId !== this.columnOverId) {
            // remove card from old column in the state
            this.$store.kanban.cards = this.$store.kanban.cards.map(kc => kc.id === card.id ? { ...kc, status: this.columnOverId } : kc);

            // Remover o card da posição atual e inserir na nova posição
            const updatedCards = this.$store.kanban.cards.filter(kc => kc.id !== card.id);
            const newColumnCards = updatedCards.filter(kc => kc.status === this.columnOverId);
            newColumnCards.splice(newCardIndex, 0, { ...card, status: this.columnOverId });

            this.$store.kanban.cards = [
              ...updatedCards.filter(kc => kc.status !== this.columnOverId),
              ...newColumnCards
            ];
            this.$store.kanban.saveState();

          } else {
            const allCards = [...this.$store.kanban.cards];
            const allCardsInColumn = allCards.filter(kc => kc.status === columnId);
            const cardIndex = allCardsInColumn.findIndex(kc => kc.id === card.id);
            allCardsInColumn.splice(cardIndex, 1);
            allCardsInColumn.splice(newCardIndex, 0, card);
            // Eu sei que isso é feio, mas eu não aguento mais ver o bug
            // Portanto, eu vou limpar o estado e recriar o quadro
            this.$store.kanban.cards = [];
            this.$nextTick(() => {
              this.$store.kanban.cards = [
                ...allCards.filter(kc => kc.status !== columnId),
                ...allCardsInColumn
              ];
              this.$store.kanban.saveState();
            });

          }

          event.target.classList.remove('dragging');
          this.draggedCard = null;
          this.draggedCardData = null;
          this.sourceColumnId = null;
        },

        handleDragOver(event, columnId) {
          event.preventDefault();

          // Se não houver um card sendo arrastado, não fazer nada
          if (!this.draggedCard || !this.draggedCardData) return;

          this.columnOverId = columnId;
          const column = event.target.closest('.column');
          if (!column) return;

          const afterElement = this.getDragAfterElement(column, event.clientY);
          const draggable = this.draggedCard;

          if (afterElement) {
            column.insertBefore(draggable, afterElement);
          } else {
            column.appendChild(draggable);
          }

        },

        getDragAfterElement(column, y) {
          const draggableElements = [...column.querySelectorAll('.card:not(.dragging)')];

          return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;

            if (offset < 0 && offset > closest.offset) {
              return { offset: offset, element: child };
            } else {
              return closest;
            }
          }, { offset: Number.NEGATIVE_INFINITY }).element;
        },

        navigateEditables(element, direction, isAlt = false) {
          const column = element.closest('.column');
          if (!column) return;

          // Se Alt está pressionado, navegar apenas entre títulos dos cards
          if (isAlt) {
            const cardTitles = Array.from(column.querySelectorAll('.card-header .title-area span'));
            const currentCard = element.closest('.card');
            let currentIndex;

            // Se estamos em uma tarefa, encontrar o título do card pai
            if (element.closest('.card-content')) {
              currentIndex = cardTitles.findIndex(title =>
                title.closest('.card').dataset.cardId === currentCard.dataset.cardId
              );
            } else {
              currentIndex = cardTitles.indexOf(element);
            }

            let nextIndex;
            if (direction === 'up') {
              nextIndex = currentIndex - 1;
            } else if (direction === 'down') {
              nextIndex = currentIndex + 1;
            }

            // Circular a navegação
            if (nextIndex < 0) {
              nextIndex = cardTitles.length - 1;
            } else if (nextIndex >= cardTitles.length) {
              nextIndex = 0;
            }

            const nextElement = cardTitles[nextIndex];
            if (nextElement) {
              nextElement.focus();
            }
          }
          // Se Alt não está pressionado, navegar entre todos os elementos editáveis da coluna
          else {
            const editables = Array.from(column.querySelectorAll('[contenteditable="true"]'));
            const currentIndex = editables.indexOf(element);
            let nextIndex;

            if (direction === 'up') {
              nextIndex = currentIndex - 1;
            } else if (direction === 'down') {
              nextIndex = currentIndex + 1;
            }

            // Circular a navegação
            if (nextIndex < 0) {
              nextIndex = editables.length - 1;
            } else if (nextIndex >= editables.length) {
              nextIndex = 0;
            }

            const nextElement = editables[nextIndex];
            if (nextElement) {
              nextElement.focus();
            }
          }
        },

        navigateColumns(element, direction, event) {
          const currentColumn = element.closest('.column');
          if (!currentColumn) return;

          const allColumns = Array.from(document.querySelectorAll('.column'));
          const currentColumnIndex = allColumns.indexOf(currentColumn);
          let nextColumnIndex;

          if (direction === 'left') {
            nextColumnIndex = currentColumnIndex - 1;
            if (nextColumnIndex < 0) nextColumnIndex = allColumns.length - 1;
          } else if (direction === 'right') {
            nextColumnIndex = currentColumnIndex + 1;
            if (nextColumnIndex >= allColumns.length) nextColumnIndex = 0;
          }

          const nextColumn = allColumns[nextColumnIndex];
          if (nextColumn) {
            // Encontrar a posição atual do card
            const currentCard = element.closest('.card');
            const cardsInCurrentColumn = Array.from(currentColumn.querySelectorAll('.card'));
            const currentPosition = cardsInCurrentColumn.indexOf(currentCard);

            // Encontrar o card na mesma posição ou a mais próxima na nova coluna
            const cardsInNextColumn = Array.from(nextColumn.querySelectorAll('.card'));
            const targetPosition = Math.min(currentPosition, cardsInNextColumn.length - 1);

            if (cardsInNextColumn.length > 0 && targetPosition >= 0) {
              const targetCard = cardsInNextColumn[targetPosition];
              const titleElement = targetCard.querySelector('.title-area span');
              if (titleElement) {
                titleElement.focus();
              }
            } else {
              // Se não houver cards na coluna, criar um novo card
              this.createCard(nextColumn.id);
            }
          }
        },

        navigateCardTitles(element, direction) {
          const column = element.closest('.column');
          if (!column) return;

          const cardTitles = Array.from(column.querySelectorAll('.card-header .title-area span'));
          const currentCard = element.closest('.card');
          let currentIndex;

          if (element.closest('.card-content')) {
            currentIndex = cardTitles.findIndex(title =>
              title.closest('.card').dataset.cardId === currentCard.dataset.cardId
            );
          } else {
            currentIndex = cardTitles.indexOf(element);
          }

          let nextIndex;
          if (direction === 'up') {
            nextIndex = currentIndex - 1;
            if (nextIndex < 0) nextIndex = cardTitles.length - 1;
          } else if (direction === 'down') {
            nextIndex = currentIndex + 1;
            if (nextIndex >= cardTitles.length) nextIndex = 0;
          }

          const nextElement = cardTitles[nextIndex];
          if (nextElement) {
            nextElement.focus();
          }
        },

        moveCard(cardId, direction) {
          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (!card) return;

          const currentColumn = document.querySelector(`#${card.status}`);
          if (!currentColumn) return;

          const allColumns = Array.from(document.querySelectorAll('.column'));
          const currentColumnIndex = allColumns.indexOf(currentColumn);
          const cardsInCurrentColumn = this.$store.kanban.cards.filter(c => c.status === card.status);
          const cardIndex = cardsInCurrentColumn.indexOf(card);

          if (direction === 'up' || direction === 'down') {
            const newIndex = direction === 'up' ? cardIndex - 1 : cardIndex + 1;
            if (newIndex >= 0 && newIndex < cardsInCurrentColumn.length) {
              cardsInCurrentColumn.splice(cardIndex, 1);
              cardsInCurrentColumn.splice(newIndex, 0, card);
              this.$store.kanban.cards = [
                ...this.$store.kanban.cards.filter(c => c.status !== card.status),
                ...cardsInCurrentColumn
              ];
            }
          } else if (direction === 'left' || direction === 'right') {
            const newColumnIndex = direction === 'left'
              ? (currentColumnIndex - 1 + allColumns.length) % allColumns.length
              : (currentColumnIndex + 1) % allColumns.length;

            const newColumn = allColumns[newColumnIndex];
            if (newColumn) {
              // Encontrar a posição atual do card na coluna
              const cardsInCurrentColumn = this.$store.kanban.cards.filter(c => c.status === card.status);
              const currentPosition = cardsInCurrentColumn.indexOf(card);

              // Remover o card da estrutura de dados
              this.$store.kanban.cards = this.$store.kanban.cards.filter(c => c.id !== cardId);
              card.status = newColumn.id;

              // Pegar os cards da nova coluna
              const cardsInNewColumn = this.$store.kanban.cards.filter(c => c.status === newColumn.id);

              // Usar a mesma posição ou a última posição disponível
              const targetIndex = Math.min(currentPosition, cardsInNewColumn.length);
              cardsInNewColumn.splice(targetIndex, 0, card);

              this.$store.kanban.cards = [
                ...this.$store.kanban.cards.filter(c => c.status !== newColumn.id),
                ...cardsInNewColumn
              ];
            }
          }

          this.$store.kanban.saveState();

          this.$nextTick(() => {
            const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
            if (cardElement) {
              const titleElement = cardElement.querySelector('.title-area span');
              if (titleElement) {
                titleElement.focus();
              }
            }
          });
        },

        reset() {
          if (!confirm('Tem certeza que deseja limpar o quadro? Todos os cards serão removidos.')) {
            return;
          }

          this.$store.kanban.cards = [];
          this.$store.kanban.saveState();

          const newCard = {
            id: this.$store.kanban.generateId(),
            status: 'todo',
            title: '',
            items: []
          };

          this.$store.kanban.cards.push(newCard);
          this.$store.kanban.saveState();

          this.$nextTick(() => {
            const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
            if (cardElement) {
              const titleElement = cardElement.querySelector('.title-area span');
              if (titleElement) {
                titleElement.focus();
              }
            }
          });
        },

        downloadState() {
          const data = JSON.stringify({
            cards: this.$store.kanban.cards,
            columns: this.$store.kanban.columns
          }, null, 2);
          const blob = new Blob([data], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `kanban-${new Date().toISOString().split('T')[0]}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        },

        uploadState(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);

              if (!data.cards || !data.columns || !Array.isArray(data.cards) || !Array.isArray(data.columns)) {
                throw new Error('Formato de arquivo inválido');
              }

              this.$store.kanban.cards = data.cards;
              this.$store.kanban.columns = data.columns;
              this.$store.kanban.saveState();
            } catch (error) {
              alert('Erro ao carregar o arquivo: ' + error.message);
            }
          };
          reader.readAsText(file);
          event.target.value = '';
        },

        handleTitleEnter(event, card) {
          this.createTaskAndFocus(card.id, -1, true);
        },

        handleTaskCtrlEnter(event, card) {
          // Encontrar o índice do card atual
          const cardsInColumn = this.$store.kanban.cards.filter(c => c.status === card.status);
          const currentIndex = cardsInColumn.indexOf(card);

          // Criar novo card após o atual
          const newCard = {
            id: this.$store.kanban.generateId(),
            status: card.status,
            title: '',
            items: []
          };

          // Inserir o novo card após o atual
          const allCards = this.$store.kanban.cards.filter(c => c.status !== card.status);
          const columnCards = this.$store.kanban.cards.filter(c => c.status === card.status);
          columnCards.splice(currentIndex + 1, 0, newCard);
          this.$store.kanban.cards = [...allCards, ...columnCards];
          this.$store.kanban.saveState();

          // Focar no título do novo card
          this.$nextTick(() => {
            const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
            if (cardElement) {
              const titleElement = cardElement.querySelector('.title-area span');
              if (titleElement) {
                titleElement.focus();
              }
            }
          });
        },

        moveTask(cardId, taskIndex, direction) {
          const card = this.$store.kanban.cards.find(card => card.id === cardId);
          if (!card || !card.items) return;

          const newIndex = direction === 'up' ? taskIndex - 1 : taskIndex + 1;
          if (newIndex < 0 || newIndex >= card.items.length) return;

          // Trocar as tarefas de posição
          const temp = card.items[taskIndex];
          card.items[taskIndex] = card.items[newIndex];
          card.items[newIndex] = temp;

          this.$store.kanban.saveState();

          // Manter o foco na tarefa movida
          this.$nextTick(() => {
            const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
            if (cardElement) {
              const tasks = cardElement.querySelectorAll('.card-content span[contenteditable]');
              const movedTask = tasks[newIndex];
              if (movedTask) {
                movedTask.focus();
              }
            }
          });
        }
      }));
    });
  </script>
</body>

</html>
