<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kanban Board</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      margin: 0;
      padding: 20px;
      color: #e0e0e0;
    }

    h1 {
      text-align: center;
      color: #ffffff;
    }

    .kanban {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .column {
      background-color: #2d2d2d;
      border-radius: 8px;
      padding: 16px;
      width: 100%;
      max-width: 350px;
      min-height: 400px;
    }

    .column h2 {
      text-align: left;
      color: #ffffff;
      margin-top: 0;
      font-size: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid #3d3d3d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .column h2 button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 20px;
      padding: 0 4px;
    }

    .card {
      background-color: #3d3d3d;
      border-radius: 4px;
      margin: 10px 0;
      color: #e0e0e0;
      border: 1px solid #4d4d4d;
      position: relative;
    }

    .card .card-header {
      height: 32px;
      background-color: #4d4d4d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 8px;
    }

    .card .card-header .drag-handle {
      display: flex;
      align-items: center;
      opacity: 0.5;
      cursor: grab;
    }

    .card .card-header .drag-handle:hover {
      opacity: 1;
    }

    .card .card-header .drag-handle svg {
      width: 10px;
      height: 16px;
    }

    .card .card-header .title-area {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      margin: 0 8px;
    }

    .card .card-header textarea {
      font-size: 14px;
      color: #ffffff;
      padding: 2px 4px;
      border-radius: 4px;
      min-width: 60px;
      background: none;
      border: none;
      width: 100%;
      resize: none;
      overflow: hidden;
      height: 20px;
      font-family: Arial, sans-serif;
    }

    .card .card-header textarea:hover {
      background-color: #5d5d5d;
    }

    .card .card-header textarea:focus {
      background-color: #5d5d5d;
      outline: none;
    }

    .card .card-header span {
      font-size: 14px;
      color: #ffffff;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
      min-width: 60px;
    }

    .card .card-header span:hover {
      background-color: #5d5d5d;
    }

    .card .card-header span:focus {
      background-color: #5d5d5d;
      outline: none;
    }

    .card .card-header .buttons {
      display: flex;
      gap: 8px;
    }

    .card .card-header button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      opacity: 0.7;
    }

    .card .card-header button:hover {
      opacity: 1;
    }

    .card .card-header button.delete {
      color: #ff4444;
    }

    .card h3 {
      margin: 0;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card h3 .buttons {
      display: flex;
      gap: 8px;
    }

    .card h3 button {
      background: none;
      border: none;
      color: #ffffff;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      opacity: 0.7;
    }

    .card h3 button:hover {
      opacity: 1;
    }

    .card h3 button.delete {
      color: #ff4444;
    }

    .card:active {
      cursor: grabbing;
    }

    .card.dragging {
      opacity: 0.5;
      outline: 2px solid #ffffff;
    }

    .card ul {
      list-style-type: none;
      padding: 0;
      margin: 10px 0 0 0;
    }

    .card ul li {
      margin: 8px 0;
      display: flex;
      align-items: start;
      color: #cccccc;
      font-size: 14px;
      padding-bottom: 6px;
      position: relative;
    }

    .card ul li:not(:last-child) {
      border-bottom: 1px solid #4d4d4d;
    }

    .card ul li button.delete-task {
      background: none;
      border: none;
      color: #ff4444;
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
      opacity: 0;
      margin-left: 4px;
    }

    .card ul li:hover button.delete-task {
      opacity: 0.7;
    }

    .card ul li button.delete-task:hover {
      opacity: 1;
    }

    .card .card-content {
      padding: 0 12px 0 12px;
    }

    .toolbar {
      text-align: right;
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .toolbar button {
      background-color: #2d2d2d;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .toolbar button:active {
      background-color: #4d4d4d;
    }

    .toolbar button svg {
      width: 16px;
      height: 16px;
    }

    .toolbar button path {
      fill: currentColor;
    }

    .toolbar button[onclick="reset()"],
    .toolbar button[onclick="reset()"]:hover,
    .toolbar button[onclick="downloadState()"],
    .toolbar button[onclick="downloadState()"]:hover,
    .toolbar button[onclick="document.getElementById('uploadInput').click()"],
    .toolbar button[onclick="document.getElementById('uploadInput').click()"]:hover {
      background-color: #2d2d2d;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background-color: #2d2d2d;
      padding: 20px;
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
    }

    .modal-content h3 {
      margin-top: 0;
      color: #ffffff;
    }

    .modal-content input[type="text"] {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      background-color: #3d3d3d;
      border: 1px solid #4d4d4d;
      color: #ffffff;
      border-radius: 4px;
    }

    .modal-content .buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .modal-content button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .modal-content button.cancel {
      background-color: #272727;
      color: #ffffff;
    }

    .modal-content button.confirm {
      background-color: #1e2f50;
      color: #ffffff;
    }

    .card h3 span {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
    }

    .card h3 span:hover {
      background-color: #4d4d4d;
    }

    .card h3 span:focus {
      background-color: #4d4d4d;
      outline: none;
    }

    .card ul li span {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: text;
    }

    .card ul li span:hover {
      background-color: #4d4d4d;
    }

    .card ul li span:focus {
      background-color: #4d4d4d;
      outline: none;
    }

    .toolbar {
      text-align: right;
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .toolbar button {
      background-color: #2d2d2d;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar button:hover {
      background-color: #3d3d3d;
    }

    .toolbar button:active {
      background-color: #4d4d4d;
    }

    .toolbar button svg {
      width: 16px;
      height: 16px;
    }

    .toolbar button path {
      fill: currentColor;
    }

    .toolbar button[onclick="reset()"],
    .toolbar button[onclick="reset()"]:hover,
    .toolbar button[onclick="downloadState()"],
    .toolbar button[onclick="downloadState()"]:hover,
    .toolbar button[onclick="document.getElementById('uploadInput').click()"],
    .toolbar button[onclick="document.getElementById('uploadInput').click()"]:hover {
      background-color: #4d4d4d;
    }

    .toolbar button:hover {
      background-color: #4d4d4d;
    }

    .outline {
      outline: 2px solid #ffffff;
    }

    /* Estilo do checkbox customizado */
    .card ul li input[type="checkbox"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border: 2px solid #dddddd;
      border-radius: 4px;
      margin-right: 8px;
      flex-shrink: 0;
      cursor: pointer;
      position: relative;
      background-color: transparent;
      transition: all 0.2s ease;
    }

    .card ul li input[type="checkbox"]:hover {
      border-color: #8b8b8b;
    }

    .card ul li input[type="checkbox"]:checked {
      background-color: #dddddd;
      border-color: #dddddd;
    }

    .card ul li input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 5px;
      top: 2px;
      width: 4px;
      height: 8px;
      border: solid rgb(0, 0, 0);
      border-width: 0 2px 2px 0;
      transform: rotate(45deg) translate(-2px, -0.5px);
    }

    .card ul li input[type="checkbox"]:checked+span {
      text-decoration: line-through;
      opacity: 0.6;
    }

    [x-cloak] {
      display: none !important;
    }

    .card ul li textarea {
      flex: 1;
      padding: 2px 4px;
      border-radius: 4px;
      background: none;
      border: none;
      color: #cccccc;
      font-size: 14px;
      resize: none;
      overflow: hidden;
      min-height: 20px;
      font-family: Arial, sans-serif;
    }

    .card ul li textarea:hover {
      background-color: #4d4d4d;
    }

    .card ul li textarea:focus {
      background-color: #4d4d4d;
      outline: none;
    }
        /* Estilo do modal */
        .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-content {
      background: #2d2d2d;
      padding: 24px;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-content h2 {
      margin: 0 0 20px 0;
      font-size: 24px;
      color: #ffffff;
    }

    .modal-content h3 {
      margin: 24px 0 12px 0;
      font-size: 18px;
      color: #dddddd;
    }

    .modal-content h3:first-of-type {
      margin-top: 0;
    }

    .modal-content ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .modal-content li {
      margin: 8px 0;
      font-size: 14px;
      color: #cccccc;
    }

    .modal-content kbd {
      background: #1a1a1a;
      border: 1px solid #4d4d4d;
      border-radius: 4px;
      padding: 2px 6px;
      font-family: monospace;
      font-size: 12px;
      color: #ffffff;
    }

    .modal-buttons {
      margin-top: 24px;
      display: flex;
      justify-content: flex-end;
    }

    .modal-buttons button {
      background-color: #222222;
      color: #ffffff;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal-buttons button:hover {
      background-color: #252525;
    }

    .modal-buttons button:active {
      background-color: #313131;
    }

    .modal-buttons button svg {
      width: 16px;
      height: 16px;
    }

    .modal-buttons button path {
      fill: currentColor;
    }

    /* Animações do modal */
    .fade-enter {
      transition: opacity 0.2s ease-out;
    }

    .fade-enter-start {
      opacity: 0;
    }

    .fade-enter-end {
      opacity: 1;
    }

    .fade-leave {
      transition: opacity 0.2s ease-in;
    }

    .fade-leave-start {
      opacity: 1;
    }

    .fade-leave-end {
      opacity: 0;
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <script type="module">
    import { h, render, Component } from 'https://esm.sh/preact';
    import { signal, effect } from 'https://esm.sh/@preact/signals';

    // Estado global
    const store = {
      cards: signal([]),
      columns: signal([
        { id: 'todo', title: 'A Fazer' },
        { id: 'doing', title: 'Fazendo' },
        { id: 'done', title: 'Feito' }
      ])
    };

    // Estado do drag and drop
    const dragState = {
      draggedCard: signal(null),
      draggedCardData: signal(null),
      sourceColumnId: signal(null),
      columnOverId: signal(null)
    };

    // Estado do card em movimento
    const cardMovingWithShift = signal(null);

    // Funções auxiliares
    const generateId = () => Math.random().toString(36).substr(2, 9);

    const getCardsByColumn = (columnId) => {
      return store.cards.value.filter(card => card.status === columnId);
    };

    const adjustTextareaHeight = (textarea) => {
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight - 2 + 'px';
    };

    // Funções de manipulação do estado
    const saveState = () => {
      try {
        localStorage.setItem('kanbanState', JSON.stringify({
          cards: store.cards.value,
          columns: store.columns.value
        }));
      } catch (e) {
        console.error('Erro ao salvar estado:', e);
      }
    };

    const createCard = (columnId) => {
      const newCard = {
        id: generateId(),
        status: columnId,
        title: '',
        items: []
      };

      store.cards.value = [...store.cards.value, newCard];
      saveState();

      // Focar no título do novo card
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
        if (cardElement) {
          const titleElement = cardElement.querySelector('.title-area textarea');
          if (titleElement) {
            titleElement.focus();
            adjustTextareaHeight(titleElement);
          }
        }
      }, 0);
    };

    const createTask = (cardId) => {
      const newTask = {
        text: '',
        checked: false
      };

      store.cards.value = store.cards.value.map(card => {
        if (card.id === cardId) {
          return {
            ...card,
            items: [...card.items, newTask]
          };
        }
        return card;
      });

      saveState();

      // Focar na nova tarefa
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
        if (cardElement) {
          const tasks = cardElement.querySelectorAll('.card-content textarea');
          const newTaskElement = tasks[tasks.length - 1];
          if (newTaskElement) {
            newTaskElement.focus();
            adjustTextareaHeight(newTaskElement);
          }
        }
      }, 0);
    };

    const updateCardTitle = (cardId, newTitle) => {
      if (!newTitle) return;

      store.cards.value = store.cards.value.map(card => {
        if (card.id === cardId) {
          return { ...card, title: newTitle };
        }
        return card;
      });

      saveState();

      // Garantir que o elemento editável reflita o estado atual
      const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
      if (cardElement) {
        const titleElement = cardElement.querySelector('.title-area textarea');
        if (titleElement && titleElement.value !== newTitle) {
          titleElement.value = newTitle;
          adjustTextareaHeight(titleElement);
        }
      }
    };

    const updateTaskText = (cardId, taskIndex, newText) => {
      if (!newText) return;

      store.cards.value = store.cards.value.map(card => {
        if (card.id === cardId) {
          const newItems = [...card.items];
          newItems[taskIndex] = { ...newItems[taskIndex], text: newText };
          return { ...card, items: newItems };
        }
        return card;
      });

      saveState();

      // Garantir que o elemento editável reflita o estado atual
      const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
      if (cardElement) {
        const tasks = cardElement.querySelectorAll('.card-content textarea');
        const taskElement = tasks[taskIndex];
        if (taskElement && taskElement.value !== newText) {
          taskElement.value = newText;
          adjustTextareaHeight(taskElement);
        }
      }
    };

    const updateTaskCheck = (cardId, taskIndex, checked) => {
      store.cards.value = store.cards.value.map(card => {
        if (card.id === cardId) {
          const newItems = [...card.items];
          newItems[taskIndex] = { ...newItems[taskIndex], checked };
          return { ...card, items: newItems };
        }
        return card;
      });

      saveState();
    };

    const deleteCard = (cardId) => {
      if (confirm('Tem certeza que deseja excluir este card?')) {
        store.cards.value = store.cards.value.filter(card => card.id !== cardId);
        saveState();
      }
    };

    const deleteTask = (cardId, taskIndex) => {
      const card = store.cards.value.find(card => card.id === cardId);
      if (!card) return;

      store.cards.value = store.cards.value.map(c => {
        if (c.id === cardId) {
          const newItems = [...c.items];
          newItems.splice(taskIndex, 1);
          return { ...c, items: newItems };
        }
        return c;
      });

      saveState();

      // Focar na próxima tarefa ou na anterior se não houver próxima
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
        if (cardElement) {
          const tasks = cardElement.querySelectorAll('.card-content span[contenteditable]');
          if (tasks.length > 0) {
            const nextTask = tasks[taskIndex] || tasks[taskIndex - 1];
            if (nextTask) {
              nextTask.focus();
            }
          }
        }
      }, 0);
    };

    const handleDragStart = (event, card) => {
      if (Object.keys(event.target).length > 0) {
        dragState.draggedCard.value = event.target;
        dragState.draggedCardData.value = card;
        dragState.sourceColumnId.value = card.status;
        setTimeout(() => event.target.classList.add('dragging'), 0);
      }
    };

    const handleDragEnd = (event, columnId, card) => {
      if (!dragState.draggedCardData.value) return;

      const column = event.target.closest('.column');
      if (!column) return;

      // get card new position on column
      const newColumn = document.querySelector(`#${dragState.columnOverId.value}`);
      const newColumnCards = newColumn.querySelectorAll('.card');
      const newCardIndex = Array.from(newColumnCards).indexOf(event.target);

      if (columnId !== dragState.columnOverId.value) {
        // remove card from old column in the state
        store.cards.value = store.cards.value.map(kc =>
          kc.id === card.id ? { ...kc, status: dragState.columnOverId.value } : kc
        );

        // Remover o card da posição atual e inserir na nova posição
        const updatedCards = store.cards.value.filter(kc => kc.id !== card.id);
        const newColumnCards = updatedCards.filter(kc => kc.status === dragState.columnOverId.value);
        newColumnCards.splice(newCardIndex, 0, { ...card, status: dragState.columnOverId.value });

        store.cards.value = [
          ...updatedCards.filter(kc => kc.status !== dragState.columnOverId.value),
          ...newColumnCards
        ];
        saveState();
      } else {
        const allCards = [...store.cards.value];
        const allCardsInColumn = allCards.filter(kc => kc.status === columnId);
        const cardIndex = allCardsInColumn.findIndex(kc => kc.id === card.id);
        allCardsInColumn.splice(cardIndex, 1);
        allCardsInColumn.splice(newCardIndex, 0, card);

        store.cards.value = [
          ...allCards.filter(kc => kc.status !== columnId),
          ...allCardsInColumn
        ];
        saveState();
      }

      event.target.classList.remove('dragging');
      dragState.draggedCard.value = null;
      dragState.draggedCardData.value = null;
      dragState.sourceColumnId.value = null;
      dragState.columnOverId.value = null;
    };

    const getDragAfterElement = (column, y) => {
      const draggableElements = [...column.querySelectorAll('.card:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    };

    const handleDragOver = (event, columnId) => {
      event.preventDefault();

      // Se não houver um card sendo arrastado, não fazer nada
      if (!dragState.draggedCard.value || !dragState.draggedCardData.value) return;

      dragState.columnOverId.value = columnId;
      const column = event.target.closest('.column');
      if (!column) return;

      const afterElement = getDragAfterElement(column, event.clientY);
      const draggable = dragState.draggedCard.value;

      if (afterElement) {
        column.insertBefore(draggable, afterElement);
      } else {
        column.appendChild(draggable);
      }
    };

    // Funções de navegação
    const navigateEditables = (element, direction, isAlt = false) => {
      const column = element.closest('.column');
      if (!column) return;

      // Se Alt está pressionado, navegar apenas entre títulos dos cards
      if (isAlt) {
        const cardTitles = Array.from(column.querySelectorAll('.card-header .title-area textarea'));
        const currentCard = element.closest('.card');
        let currentIndex;

        // Se estamos em uma tarefa, encontrar o título do card pai
        if (element.closest('.card-content')) {
          currentIndex = cardTitles.findIndex(title =>
            title.closest('.card').dataset.cardId === currentCard.dataset.cardId
          );
        } else {
          currentIndex = cardTitles.indexOf(element);
        }

        let nextIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;

        // Circular a navegação
        if (nextIndex < 0) {
          nextIndex = cardTitles.length - 1;
        } else if (nextIndex >= cardTitles.length) {
          nextIndex = 0;
        }

        const nextElement = cardTitles[nextIndex];
        if (nextElement) {
          nextElement.focus();
        }
      }
      // Se Alt não está pressionado, navegar entre todos os elementos editáveis da coluna
      else {
        const editables = Array.from(column.querySelectorAll('textarea'));
        const currentIndex = editables.indexOf(element);
        let nextIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;

        // Circular a navegação
        if (nextIndex < 0) {
          nextIndex = editables.length - 1;
        } else if (nextIndex >= editables.length) {
          nextIndex = 0;
        }

        const nextElement = editables[nextIndex];
        if (nextElement) {
          nextElement.focus();
        }
      }
    };

    const navigateColumns = (element, direction) => {
      const currentColumn = element.closest('.column');
      if (!currentColumn) return;

      const allColumns = Array.from(document.querySelectorAll('.column'));
      const currentColumnIndex = allColumns.indexOf(currentColumn);
      let nextColumnIndex;

      if (direction === 'left') {
        nextColumnIndex = currentColumnIndex - 1;
        if (nextColumnIndex < 0) nextColumnIndex = allColumns.length - 1;
      } else if (direction === 'right') {
        nextColumnIndex = currentColumnIndex + 1;
        if (nextColumnIndex >= allColumns.length) nextColumnIndex = 0;
      }

      const nextColumn = allColumns[nextColumnIndex];
      if (nextColumn) {
        // Encontrar a posição atual do card
        const currentCard = element.closest('.card');
        const cardsInCurrentColumn = Array.from(currentColumn.querySelectorAll('.card'));
        const currentPosition = cardsInCurrentColumn.indexOf(currentCard);

        // Encontrar o card na mesma posição ou a mais próxima na nova coluna
        const cardsInNextColumn = Array.from(nextColumn.querySelectorAll('.card'));
        const targetPosition = Math.min(currentPosition, cardsInNextColumn.length - 1);

        if (cardsInNextColumn.length > 0 && targetPosition >= 0) {
          const targetCard = cardsInNextColumn[targetPosition];
          const titleElement = targetCard.querySelector('.title-area textarea');
          if (titleElement) {
            titleElement.focus();
          }
        } else {
          // Se não houver cards na coluna, criar um novo card
          createCard(nextColumn.id);
        }
      }
    };

    const moveCard = (cardId, direction) => {
      const card = store.cards.value.find(card => card.id === cardId);
      if (!card) return;

      const currentColumn = document.querySelector(`#${card.status}`);
      if (!currentColumn) return;

      const allColumns = Array.from(document.querySelectorAll('.column'));
      const currentColumnIndex = allColumns.indexOf(currentColumn);
      const cardsInCurrentColumn = store.cards.value.filter(c => c.status === card.status);
      const cardIndex = cardsInCurrentColumn.indexOf(card);

      if (direction === 'up' || direction === 'down') {
        const newIndex = direction === 'up' ? cardIndex - 1 : cardIndex + 1;
        if (newIndex >= 0 && newIndex < cardsInCurrentColumn.length) {
          cardsInCurrentColumn.splice(cardIndex, 1);
          cardsInCurrentColumn.splice(newIndex, 0, card);
          store.cards.value = [
            ...store.cards.value.filter(c => c.status !== card.status),
            ...cardsInCurrentColumn
          ];
        }
      } else if (direction === 'left' || direction === 'right') {
        const newColumnIndex = direction === 'left'
          ? (currentColumnIndex - 1 + allColumns.length) % allColumns.length
          : (currentColumnIndex + 1) % allColumns.length;

        const newColumn = allColumns[newColumnIndex];
        if (newColumn) {
          // Encontrar a posição atual do card na coluna
          const cardsInCurrentColumn = store.cards.value.filter(c => c.status === card.status);
          const currentPosition = cardsInCurrentColumn.indexOf(card);

          // Remover o card da estrutura de dados
          store.cards.value = store.cards.value.filter(c => c.id !== cardId);
          card.status = newColumn.id;

          // Pegar os cards da nova coluna
          const cardsInNewColumn = store.cards.value.filter(c => c.status === newColumn.id);

          // Usar a mesma posição ou a última posição disponível
          const targetIndex = Math.min(currentPosition, cardsInNewColumn.length);
          cardsInNewColumn.splice(targetIndex, 0, card);

          store.cards.value = [
            ...store.cards.value.filter(c => c.status !== newColumn.id),
            ...cardsInNewColumn
          ];
        }
      }

      saveState();

      // Manter o foco no título do card movido
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
        if (cardElement) {
          const titleElement = cardElement.querySelector('.title-area textarea');
          if (titleElement) {
            titleElement.focus();
          }
        }
      }, 0);
    };

    const moveTask = (cardId, taskIndex, direction) => {
      const card = store.cards.value.find(card => card.id === cardId);
      if (!card || !card.items) return;

      const newIndex = direction === 'up' ? taskIndex - 1 : taskIndex + 1;
      if (newIndex < 0 || newIndex >= card.items.length) return;

      // Trocar as tarefas de posição
      const temp = card.items[taskIndex];
      card.items[taskIndex] = card.items[newIndex];
      card.items[newIndex] = temp;

      store.cards.value = store.cards.value.map(c =>
        c.id === cardId ? { ...c, items: [...card.items] } : c
      );

      saveState();

      // Manter o foco na tarefa movida
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${cardId}"]`);
        if (cardElement) {
          const tasks = cardElement.querySelectorAll('.card-content textarea');
          const movedTask = tasks[newIndex];
          if (movedTask) {
            movedTask.focus();
          }
        }
      }, 0);
    };

    // Funções da barra de ferramentas
    const reset = () => {
      if (!confirm('Tem certeza que deseja limpar o quadro? Todos os cards serão removidos.')) {
        return;
      }

      const newCard = {
        id: generateId(),
        status: 'todo',
        title: '',
        items: []
      };

      store.cards.value = [newCard];
      saveState();

      // Focar e ajustar altura do textarea do novo card
      setTimeout(() => {
        const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
        if (cardElement) {
          const titleElement = cardElement.querySelector('.title-area textarea');
          if (titleElement) {
            titleElement.focus();
            adjustTextareaHeight(titleElement);
          }
        }
      }, 0);
    };

    const downloadState = () => {
      const data = JSON.stringify({
        cards: store.cards.value,
        columns: store.columns.value
      }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `kanban-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    };

    const uploadState = (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          if (!data.cards || !data.columns || !Array.isArray(data.cards) || !Array.isArray(data.columns)) {
            throw new Error('Formato de arquivo inválido');
          }

          store.cards.value = data.cards;
          store.columns.value = data.columns;
          saveState();

          // Ajustar altura dos textareas após o carregamento
          setTimeout(() => {
            document.querySelectorAll('textarea').forEach(textarea => {
              adjustTextareaHeight(textarea);
            });
          }, 0);
        } catch (error) {
          alert('Erro ao carregar o arquivo: ' + error.message);
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    };

    // Estado do modal de atalhos
    const isShortcutsModalOpen = signal(false);

    // Componente do modal de atalhos
    const ShortcutsModal = () => {
      if (!isShortcutsModalOpen.value) return null;

      return h('div', {
        class: 'modal-overlay',
        onClick: () => isShortcutsModalOpen.value = false
      }, [
        h('div', {
          class: 'modal-content',
          onClick: (e) => e.stopPropagation()
        }, [
          h('h2', {}, 'Atalhos de Teclado'),

          h('h3', {}, 'Navegação'),
          h('ul', {}, [
            h('li', {}, [
              h('kbd', {}, '↑'),
              ' / ',
              h('kbd', {}, '↓'),
              ' - Navega entre elementos editáveis na mesma coluna'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Alt'),
              ' + ',
              h('kbd', {}, '↑'),
              ' / ',
              h('kbd', {}, '↓'),
              ' - Navega apenas entre títulos dos cards na mesma coluna'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Alt'),
              ' + ',
              h('kbd', {}, '←'),
              ' / ',
              h('kbd', {}, '→'),
              ' - Navega para o card na mesma posição na coluna adjacente'
            ])
          ]),

          h('h3', {}, 'Movimentação de Cards'),
          h('ul', {}, [
            h('li', {}, [
              h('kbd', {}, 'Shift'),
              ' + ',
              h('kbd', {}, '↑'),
              ' / ',
              h('kbd', {}, '↓'),
              ' - Move o card para cima/baixo na mesma coluna'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Shift'),
              ' + ',
              h('kbd', {}, '←'),
              ' / ',
              h('kbd', {}, '→'),
              ' - Move o card para a coluna da esquerda/direita mantendo a mesma posição'
            ])
          ]),

          h('h3', {}, 'Movimentação de Tarefas'),
          h('ul', {}, [
            h('li', {}, [
              h('kbd', {}, 'Ctrl'),
              ' + ',
              h('kbd', {}, '↑'),
              ' / ',
              h('kbd', {}, '↓'),
              ' - Move a tarefa para cima/baixo dentro do card'
            ])
          ]),

          h('h3', {}, 'Edição'),
          h('ul', {}, [
            h('li', {}, [
              h('kbd', {}, 'Ctrl'),
              ' + ',
              h('kbd', {}, 'Espaço'),
              ' em uma tarefa - Marca/desmarca a tarefa como concluída'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Enter'),
              ' no título - Cria uma nova tarefa no topo do card'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Ctrl'),
              ' + ',
              h('kbd', {}, 'Enter'),
              ' no título - Cria novo card abaixo do atual'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Enter'),
              ' em uma tarefa - Cria nova tarefa abaixo'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Ctrl'),
              ' + ',
              h('kbd', {}, 'Enter'),
              ' em uma tarefa - Cria novo card abaixo do atual'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Delete'),
              ' no título - Exclui o card (com confirmação)'
            ]),
            h('li', {}, [
              h('kbd', {}, 'Delete'),
              ' em uma tarefa - Exclui a tarefa imediatamente'
            ])
          ]),

          h('div', { class: 'modal-buttons' }, [
            h('button', {
              onClick: () => isShortcutsModalOpen.value = false
            }, [
              h('svg', {
                viewBox: '0 0 24 24',
                xmlns: 'http://www.w3.org/2000/svg'
              }, [
                h('path', {
                  d: 'M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12zM5 18v2h14v-2H5z'
                })
              ]),
              'Fechar'
            ])
          ])
        ])
      ]);
    };

    // Componentes
    const Card = ({ card }) => {
      return h('div', {
        class: `card ${cardMovingWithShift.value === card.id ? 'outline' : ''}`,
        'data-card-id': card.id,
        draggable: true,
        onDragStart: (e) => handleDragStart(e, card),
        onDragEnd: (e) => handleDragEnd(e, card.status, card)
      }, [
        h('div', { class: 'card-header' }, [
          h('div', { class: 'drag-handle' }, [
            h('svg', {
              viewBox: '0 0 12 18',
              fill: 'none',
              xmlns: 'http://www.w3.org/2000/svg'
            }, [
              h('circle', { cx: '3', cy: '3', r: '1.5', fill: '#ffffff' }),
              h('circle', { cx: '9', cy: '3', r: '1.5', fill: '#ffffff' }),
              h('circle', { cx: '3', cy: '9', r: '1.5', fill: '#ffffff' }),
              h('circle', { cx: '9', cy: '9', r: '1.5', fill: '#ffffff' }),
              h('circle', { cx: '3', cy: '15', r: '1.5', fill: '#ffffff' }),
              h('circle', { cx: '9', cy: '15', r: '1.5', fill: '#ffffff' })
            ])
          ]),
          h('div', { class: 'title-area' }, [
            h('textarea', {
              value: card.title,
              rows: 1,
              onBlur: (e) => updateCardTitle(card.id, e.target.value.trim()),
              onInput: (e) => {
                updateCardTitle(card.id, e.target.value.trim());
              },
              onKeyDown: (e) => {
                if (e.key === 'Shift') {
                  cardMovingWithShift.value = card.id;
                } else if (e.key === 'Enter') {
                  e.preventDefault();
                  if (e.ctrlKey) {
                    // Criar novo card abaixo
                    const newCard = {
                      id: generateId(),
                      status: card.status,
                      title: '',
                      items: []
                    };
                    const currentIndex = store.cards.value.findIndex(c => c.id === card.id);
                    const allCards = [...store.cards.value];
                    allCards.splice(currentIndex + 1, 0, newCard);
                    store.cards.value = allCards;
                    saveState();

                    // Focar no título do novo card
                    setTimeout(() => {
                      const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
                      if (cardElement) {
                        const titleElement = cardElement.querySelector('.title-area textarea');
                        if (titleElement) {
                          titleElement.focus();
                        }
                      }
                    }, 0);
                  } else {
                    // Criar nova tarefa no topo
                    const newTask = {
                      text: '',
                      checked: false
                    };

                    store.cards.value = store.cards.value.map(c => {
                      if (c.id === card.id) {
                        return {
                          ...c,
                          items: [newTask, ...c.items]
                        };
                      }
                      return c;
                    });
                    saveState();

                    // Focar na nova tarefa
                    setTimeout(() => {
                      const cardElement = document.querySelector(`[data-card-id="${card.id}"]`);
                      if (cardElement) {
                        const tasks = cardElement.querySelectorAll('.card-content textarea');
                        if (tasks.length > 0) {
                          tasks[0].focus();
                        }
                      }
                    }, 0);
                  }
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                  e.preventDefault();
                  if (e.shiftKey) {
                    moveCard(card.id, e.key === 'ArrowUp' ? 'up' : 'down');
                  } else if (e.altKey) {
                    navigateEditables(e.target, e.key === 'ArrowUp' ? 'up' : 'down', true);
                  } else {
                    navigateEditables(e.target, e.key === 'ArrowUp' ? 'up' : 'down');
                  }
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                  if (e.shiftKey) {
                    e.preventDefault();
                    moveCard(card.id, e.key === 'ArrowLeft' ? 'left' : 'right');
                  } else if (e.altKey) {
                    e.preventDefault();
                    navigateColumns(e.target, e.key === 'ArrowLeft' ? 'left' : 'right');
                  }
                } else if (e.key === 'Delete' && e.target.value === '') {
                  e.preventDefault();
                  deleteCard(card.id);
                }
              },
              onKeyUp: (e) => {
                if (e.key === 'Shift') {
                  cardMovingWithShift.value = null;
                }
              }
            })
          ]),
          h('div', { class: 'buttons' }, [
            h('button', {
              onClick: () => createTask(card.id),
              title: 'Adicionar tarefa'
            }, '+'),
            h('button', {
              class: 'delete',
              onClick: () => deleteCard(card.id),
              title: 'Excluir card'
            }, '×')
          ])
        ]),
        h('div', { class: 'card-content' }, [
          h('ul', {}, card.items.map((item, index) =>
            h('li', { key: index }, [
              h('input', {
                type: 'checkbox',
                checked: item.checked,
                onChange: (e) => updateTaskCheck(card.id, index, e.target.checked)
              }),
              h('textarea', {
                value: item.text,
                rows: 1,
                onBlur: (e) => updateTaskText(card.id, index, e.target.value.trim()),
                onInput: (e) => {
                  updateTaskText(card.id, index, e.target.value.trim());
                },
                onKeyDown: (e) => {
                  if (e.key === 'Shift') {
                    cardMovingWithShift.value = card.id;
                  } else if (e.key === ' ' && e.ctrlKey) {
                    e.preventDefault();
                    updateTaskCheck(card.id, index, !item.checked);
                  } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.ctrlKey) {
                      // Criar novo card abaixo
                      const newCard = {
                        id: generateId(),
                        status: card.status,
                        title: '',
                        items: []
                      };
                      const currentIndex = store.cards.value.findIndex(c => c.id === card.id);
                      const allCards = [...store.cards.value];
                      allCards.splice(currentIndex + 1, 0, newCard);
                      store.cards.value = allCards;
                      saveState();

                      // Focar no título do novo card
                      setTimeout(() => {
                        const cardElement = document.querySelector(`[data-card-id="${newCard.id}"]`);
                        if (cardElement) {
                          const titleElement = cardElement.querySelector('.title-area textarea');
                          if (titleElement) {
                            titleElement.focus();
                          }
                        }
                      }, 0);
                    } else {
                      // Criar nova tarefa abaixo
                      const newTask = {
                        text: '',
                        checked: false
                      };

                      store.cards.value = store.cards.value.map(c => {
                        if (c.id === card.id) {
                          const newItems = [...c.items];
                          newItems.splice(index + 1, 0, newTask);
                          return { ...c, items: newItems };
                        }
                        return c;
                      });
                      saveState();

                      // Focar na nova tarefa
                      setTimeout(() => {
                        const cardElement = document.querySelector(`[data-card-id="${card.id}"]`);
                        if (cardElement) {
                          const tasks = cardElement.querySelectorAll('.card-content textarea');
                          const newTaskElement = tasks[index + 1];
                          if (newTaskElement) {
                            newTaskElement.focus();
                          }
                        }
                      }, 0);
                    }
                  } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (e.ctrlKey) {
                      moveTask(card.id, index, e.key === 'ArrowUp' ? 'up' : 'down');
                    } else if (e.shiftKey) {
                      moveCard(card.id, e.key === 'ArrowUp' ? 'up' : 'down');
                    } else if (e.altKey) {
                      navigateEditables(e.target, e.key === 'ArrowUp' ? 'up' : 'down', true);
                    } else {
                      navigateEditables(e.target, e.key === 'ArrowUp' ? 'up' : 'down');
                    }
                  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    if (e.shiftKey) {
                      e.preventDefault();
                      moveCard(card.id, e.key === 'ArrowLeft' ? 'left' : 'right');
                    } else if (e.altKey) {
                      e.preventDefault();
                      navigateColumns(e.target, e.key === 'ArrowLeft' ? 'left' : 'right');
                    }
                  } else if (e.key === 'Delete' && e.target.value === '') {
                    e.preventDefault();
                    deleteTask(card.id, index);
                  }
                },
                onKeyUp: (e) => {
                  if (e.key === 'Shift') {
                    cardMovingWithShift.value = null;
                  }
                }
              }),
              h('button', {
                class: 'delete-task',
                onClick: () => deleteTask(card.id, index),
                title: 'Excluir tarefa'
              }, '×')
            ])
          ))
        ])
      ]);
    };

    const Column = ({ column }) => {
      return h('div', {
        class: 'column',
        id: column.id,
        onDragOver: (e) => handleDragOver(e, column.id)
      }, [
        h('h2', {}, [
          h('span', {}, column.title),
          h('button', {
            onClick: () => createCard(column.id)
          }, '+')
        ]),
        ...getCardsByColumn(column.id).map(card =>
          h(Card, { key: card.id, card })
        )
      ]);
    };

    const Toolbar = () => {
      return h('div', { class: 'toolbar' }, [
        h('button', {
          onClick: reset,
          title: 'Resetar quadro'
        }, [
          h('svg', {
            viewBox: '0 0 24 24',
            xmlns: 'http://www.w3.org/2000/svg'
          }, [
            h('path', {
              d: 'M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z'
            })
          ]),
          'Resetar'
        ]),
        h('button', {
          onClick: downloadState,
          title: 'Baixar quadro'
        }, [
          h('svg', {
            viewBox: '0 0 24 24',
            xmlns: 'http://www.w3.org/2000/svg'
          }, [
            h('path', {
              d: 'M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z'
            })
          ]),
          'Baixar'
        ]),
        h('button', {
          onClick: () => document.getElementById('uploadInput').click(),
          title: 'Carregar quadro'
        }, [
          h('svg', {
            viewBox: '0 0 24 24',
            xmlns: 'http://www.w3.org/2000/svg'
          }, [
            h('path', {
              d: 'M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z'
            })
          ]),
          'Carregar'
        ]),
        h('button', {
          onClick: () => isShortcutsModalOpen.value = true,
          title: 'Atalhos de teclado'
        }, [
          h('svg', {
            viewBox: '0 0 24 24',
            xmlns: 'http://www.w3.org/2000/svg'
          }, [
            h('path', {
              d: 'M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2z'
            })
          ]),
          'Atalhos'
        ]),
        h('input', {
          type: 'file',
          id: 'uploadInput',
          accept: '.json',
          style: { display: 'none' },
          onChange: uploadState
        })
      ]);
    };

    const App = () => {
      // Carregar estado inicial
      effect(() => {
        try {
          const savedData = localStorage.getItem('kanbanState');
          if (savedData) {
            const data = JSON.parse(savedData);
            store.cards.value = data.cards;
            store.columns.value = data.columns;
          }
        } catch (e) {
          console.error('Erro ao carregar dados do localStorage:', e);
        }
      });

      // Ajustar altura dos textareas sempre que houver mudanças nos cards
      effect(() => {
        // Acessar o valor dos cards para criar a dependência
        const cards = store.cards.value;
        
        // Usar setTimeout para garantir que o DOM foi atualizado
        setTimeout(() => {
          document.querySelectorAll('textarea').forEach(textarea => {
            adjustTextareaHeight(textarea);
          });
        }, 0);
      });

      // Adicionar listener para fechar o modal com Esc
      effect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape' && isShortcutsModalOpen.value) {
            isShortcutsModalOpen.value = false;
          }
        };

        document.addEventListener('keydown', handleKeyDown);
        return () => document.removeEventListener('keydown', handleKeyDown);
      });

      return h('div', {}, [
        h('h1', {}, 'Kanban Board'),
        h(Toolbar),
        h('div', { class: 'kanban' },
          store.columns.value.map(column =>
            h(Column, { key: column.id, column })
          )
        ),
        h(ShortcutsModal)
      ]);
    };

    // Renderizar aplicação
    render(h(App, {}), document.getElementById('app'));
  </script>    
</body>

</html>